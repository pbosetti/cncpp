/******************************************************************************
Finite State Machine
Project: src/fsm.dot
Description: C-CNC

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.4.0
Generation date: 2024-10-16 12:59:15 +0200
Generated from: src/fsm.dot
The finite state machine has:
  8 states
  7 transition functions

******************************************************************************/

#include <syslog.h>
#include "fsm.hpp"
#include <keystroker.h>
#include <algorithm>
    
using namespace std;
using namespace rang;
    

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!


namespace FSM {

/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state STATE_INIT
// valid return states: STATE_IDLE, STATE_STOP
template<class T> 
state_t do_init(T &data) {
  state_t next_state = FSM::STATE_IDLE;

  // STEPS:
  // 1. Connect to machine (MQTT broker)
  data.machine.connect();

  // 2. Set machine to zero
  data.machine.position(data.machine.zero());
  data.machine.setpoint(data.machine.zero());

  // 3. Message user
  cerr << fg::green << "Connected to machine "
       << style::bold << data.machine.mqtt_host()
       << style::reset << fg::reset << endl;

  return next_state;
}

// Function to be executed in state STATE_IDLE
// valid return states: NO_CHANGE, STATE_IDLE, STATE_LOAD_BLOCK, STATE_STOP, STATE_GO_TO_ZERO
// SIGINT triggers an emergency transition to STATE_STOP
template<class T> 
state_t do_idle(T &data) {
  state_t next_state = FSM::NO_CHANGE;

  // STEPS:
  // 1. Wait for user input
  cerr << "Press " << fg::green << "<space>" << fg::reset
       << " to run, " << fg::blue << "z" << fg::reset
       << " to go to zero, " << fg ::red << "q" << fg::reset
       << " to quit" << endl;
  char key = keystroker::read_key();

  // 2. select next state
  switch(key) {
  case ' ':
    next_state = FSM::STATE_LOAD_BLOCK;
    data.program.rewind();
    break;
  case 'q':
  case 'Q':
    next_state = FSM::STATE_STOP;
    break;
  case 'z':
  case 'Z':
    next_state = FSM::STATE_GO_TO_ZERO;
    break;
  default:
    break;
  }

  // 3. Reset timing
  data.t_tot  = 0;
  data.t_blk  = 0;

  return next_state;
}

// Function to be executed in state STATE_STOP
// valid return states: NO_CHANGE
template<class T> 
state_t do_stop(T &data) {
  state_t next_state = FSM::STATE_STOP;

  // STEPS:
  // 1. Reset signal handler
  signal(SIGINT, SIG_DFL);

  // 2. Disconnect from machine
  data.machine.listen_stop();

  // 3. Message user
  cerr << fg::red << style::bold << "STOP" << fg::reset << style::reset << endl;

  return next_state;
}

// Function to be executed in state STATE_LOAD_BLOCK
// valid return states: STATE_IDLE, STATE_NO_MOTION, STATE_RAPID_MOTION, STATE_INTERP_MOTION
template<class T> 
state_t do_load_block(T &data) {
  state_t next_state = FSM::STATE_RAPID_MOTION;

  // STEPS:
  // 1. Load next block, go back to idle if it's the last one
  data.program.load_next();
  if (data.program.done()) {
    return FSM::STATE_IDLE;
  }

  // 2. Check current block type and set next state
  cncpp::Block &b = *data.program.current();
  cerr << "Loading " << b.desc() << endl;
  switch (b.type()) {
  case cncpp::Block::BlockType::NO_MOTION:
    next_state = FSM::STATE_NO_MOTION;
    break;
  case cncpp::Block::BlockType::RAPID:
    next_state = FSM::STATE_RAPID_MOTION;
    break;
  case cncpp::Block::BlockType::LINE:
  case cncpp::Block::BlockType::CWA:
  case cncpp::Block::BlockType::CCWA:
    next_state = FSM::STATE_INTERP_MOTION;
    break;
  default:
    next_state = FSM::STATE_IDLE;
    break;
  }

  // 3. Increment total time
  data.t_tot += data.machine.tq();
  
  return next_state;
}

// Function to be executed in state STATE_GO_TO_ZERO
// valid return states: NO_CHANGE, STATE_IDLE, STATE_GO_TO_ZERO
// SIGINT triggers an emergency transition to STATE_STOP
template<class T> 
state_t do_go_to_zero(T &data) {
  state_t next_state = FSM::NO_CHANGE;

  // STEPS:
  // 1. sync machine setpoint
  data.machine.sync(true);

  // 2. check if we are at zero
  if (data.machine.error() < data.machine.max_error()) {
    next_state = FSM::STATE_IDLE;
  } 

  // 3. check if we need to stop for CTRL-C; if so, go to IDLE state
  //    to skip over a rapid block
  if (stop_requested) {
    stop_requested = false;
    next_state = FSM::STATE_IDLE;
  }
  
  return next_state;
}

// Function to be executed in state STATE_NO_MOTION
// valid return states: STATE_LOAD_BLOCK
template<class T> 
state_t do_no_motion(T &data) {
  state_t next_state = FSM::STATE_LOAD_BLOCK;

  // STEPS:
  // 1. Print warning
  cerr << fg::yellow << "No motion block: " << fg::reset
       << (*data.program.current()).desc() << endl;

  // 2. Increment total time
  data.t_tot += data.machine.tq();
  
  return next_state;
}

// Function to be executed in state STATE_RAPID_MOTION
// valid return states: NO_CHANGE, STATE_LOAD_BLOCK, STATE_RAPID_MOTION
// SIGINT triggers an emergency transition to STATE_STOP
template<class T> 
state_t do_rapid_motion(T &data) {
  state_t next_state = FSM::NO_CHANGE;
  data_t duration;
  cncpp::Block &b = *data.program.current();

  // STEPS:
  // 1. Sync machine setpoint
  data.machine.sync(true);

  // 2. Exit if the error is small or the time has elapsed
  duration = b.length() / data.machine.fmax() * 60.0;
  if (data.machine.error() < data.machine.max_error() && data.t_blk > duration) {
    next_state = FSM::STATE_LOAD_BLOCK;
  }

  // 3. Deal with CTRL-C for skipping over a rapid block
  if (stop_requested) {
    stop_requested = false;
    next_state = FSM::STATE_LOAD_BLOCK;
  }

  // 4. Get current position and print values table
  cncpp::Point p = data.machine.position();
  data_t rel_distance = min(data.machine.error() / b.length(), 1.0);
  cout << fmt::format("{:0>3d} {:0>2d} {:.3f} {:.3f} {:.3f} {:.3f} {:.1f} {:.3f} {:.3f} {:.3f} {:.3f}", b.n(), static_cast<int>(b.type()), data.t_tot, data.t_blk, rel_distance, rel_distance * b.length(), data.machine.fmax(), b.profile().current_acc, p.x(), p.y(), p.z()) << endl;

  // 5. Increment total and block time
  data.t_blk += data.machine.tq();
  data.t_tot += data.machine.tq();
  
  return next_state;
}

// Function to be executed in state STATE_INTERP_MOTION
// valid return states: NO_CHANGE, STATE_LOAD_BLOCK, STATE_INTERP_MOTION
// SIGINT triggers an emergency transition to STATE_STOP
template<class T> 
state_t do_interp_motion(T &data) {
  state_t next_state = FSM::NO_CHANGE;
  cncpp::Block &b = *data.program.current();
  data_t lambda, speed;
  data_t tq = data.machine.tq();

  // STEPS:
  // 1. Interpolate position
  cncpp::Point p = b.interpolate(data.t_blk, lambda, speed);

  // 2. Print values table
  cout << fmt::format("{:0>3d} {:0>2d} {:.3f} {:.3f} {:.3f} {:.3f} {:.1f} {:.3f} {:.3f} {:.3f} {:.3f}", b.n(), static_cast<int>(b.type()), data.t_tot, data.t_blk, lambda, lambda * b.length(), speed, b.profile().current_acc, p.x(), p.y(), p.z()) << endl;

  // 3. Sync machine setpoint
  data.machine.setpoint(p);
  data.machine.sync(false);

  // 4. Chck if we are done
  if (data.t_blk > b.dt() + tq / 10.0) {
    next_state = FSM::STATE_LOAD_BLOCK;
  }

  // 5. Increment total and block time
  data.t_blk += tq;
  data.t_tot += tq;
  
  return next_state;
}


/*  _____                    _ _   _              
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
 *                                                
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                              

// This function is called in 1 transition:
// 1. from idle to load_block
template<class T>
void reset(T &data) {
  data.t_tot = 0;
  data.t_blk = 0;
  cout << "# n type t_tot t_blk lambda s feedrate acc x y z" << endl;
}

// This function is called in 1 transition:
// 1. from idle to go_to_zero
template<class T>
void begin_zero(T &data) {
  data.machine.listen_start();
  data.machine.setpoint(data.machine.zero());
  data.machine.sync(true);
  cerr << "Going to zero.at " << data.machine.zero().desc() << "..." << endl;
}

// This function is called in 1 transition:
// 1. from load_block to rapid_motion
template<class T>
void begin_rapid(T &data) {
  cncpp::Block &b = *data.program.current();
  data.t_blk = 0;
  data.machine.listen_start();
  data.machine.setpoint(b.target());
  data.machine.sync(true);
}

// This function is called in 1 transition:
// 1. from load_block to interp_motion
template<class T>
void begin_interp(T &data) {
  data.t_blk = 0;
}

// This function is called in 1 transition:
// 1. from rapid_motion to load_block
template<class T>
void end_rapid(T &data) {
  data.machine.listen_stop();
}

// This function is called in 1 transition:
// 1. from interp_motion to load_block
template<class T>
void end_interp(T &data) {
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from go_to_zero to idle
template<class T>
void end_zero(T &data) {
  data.machine.listen_stop();
}


}; // namespace FSM


// Example usage:
#ifdef TEST_MAIN
#include <unistd.h>
#include <thread>

struct Data {
  int count;
};

int main() {
  Data data = {1};
  auto fsm = FSM::FiniteStateMachine(&data);
  fsm.set_timing_function([]() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
  });
  fsm.run([&](Data &s) {
    std::cout << "State: " << fsm.state() << " data: " << s.count << std::endl;
  });
  return 0;
}
#endif // TEST_MAIN
