/******************************************************************************
Finite State Machine
Project: src/fsm.dot
Description: C-CNC

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.5.1
Generation date: 2025-01-28 15:00:29 +0100
Generated from: src/fsm.dot
The finite state machine has:
  8 states
  7 transition functions

******************************************************************************/

#ifndef FSM_HPP
#define FSM_HPP
#include <functional>
#include <iostream>
#include <map>
#include <string>
#include <tuple>
// Install signal handler: 
// SIGINT requests a transition to state stop
#include <csignal>


using namespace std::string_literals;
namespace FSM {
static bool stop_requested = false;

// List of states
typedef enum {
  STATE_INIT,
  STATE_IDLE,
  STATE_STOP,
  STATE_LOAD_BLOCK,
  STATE_GO_TO_ZERO,
  STATE_NO_MOTION,
  STATE_RAPID_MOTION,
  STATE_INTERP_MOTION,
  NUM_STATES,
  NO_CHANGE,
  UNIMPLEMENTED
} state_t;

// State human-readable names
std::map<state_t, char const *> state_names = {
  {STATE_INIT, "INIT"},
  {STATE_IDLE, "IDLE"},
  {STATE_STOP, "STOP"},
  {STATE_LOAD_BLOCK, "LOAD_BLOCK"},
  {STATE_GO_TO_ZERO, "GO_TO_ZERO"},
  {STATE_NO_MOTION, "NO_MOTION"},
  {STATE_RAPID_MOTION, "RAPID_MOTION"},
  {STATE_INTERP_MOTION, "INTERP_MOTION"},
  {NUM_STATES, "NUM_STATES"},
  {NO_CHANGE, "NO_CHANGE"},
  {UNIMPLEMENTED, "UNIMPLEMENTED"}
};

// Custom state functions:
template<class T> 
state_t do_init(T &data);
template<class T> 
state_t do_idle(T &data);
template<class T> 
state_t do_stop(T &data);
template<class T> 
state_t do_load_block(T &data);
template<class T> 
state_t do_go_to_zero(T &data);
template<class T> 
state_t do_no_motion(T &data);
template<class T> 
state_t do_rapid_motion(T &data);
template<class T> 
state_t do_interp_motion(T &data);

// Custom transition functions:
template<class T>
void reset(T &data);
template<class T>
void begin_zero(T &data);
template<class T>
void begin_rapid(T &data);
template<class T>
void begin_interp(T &data);
template<class T>
void end_rapid(T &data);
template<class T>
void end_interp(T &data);
template<class T>
void end_zero(T &data);

// Finite State Machine class
template <typename DATA_T> 
class FiniteStateMachine {

// Function templates
using state_fun = std::function<state_t(DATA_T &data)>;
using transition_fun = std::function<void(DATA_T &data)>;
using operation_fun = std::function<void(DATA_T &data)>;

private:
  std::pair<state_t, state_t> _state{STATE_INIT, STATE_INIT};
  std::map<state_t, state_fun> _states;
  std::map<state_t, std::map<state_t, transition_fun>> _transitions;
  std::function<void()> _timing_func;
  DATA_T *_data;

public:

  FiniteStateMachine(DATA_T *data) : _data(data) {
    install_functions();
  }
  ~FiniteStateMachine(){};

  void set_timing_function(std::function<void()> timing_func) {
    _timing_func = timing_func;
  }

  void add_state(state_t name, state_fun func) { _states[name] = func; }

  void add_transition(state_t from, state_t to, transition_fun func) {
    _transitions[from][to] = func;
  }

  inline state_t state() { return _state.second; }
  inline std::string state_name() { return std::string(state_names[_state.second]); }
  inline state_t prev_state() { return _state.first; }

  state_t operator()(state_t state) {
    if (_states.find(state) == _states.end()) {
      throw std::runtime_error("State not found: "s + state_names[state]);
    }
    state_t next = _states[state](*_data);
    if (next == NO_CHANGE) {
      next = state;
    }
    return next;
  }

  void operator()(state_t from, state_t to) {
    if (_transitions.find(from) != _transitions.end()) {
      if (_transitions[from].find(to) != _transitions[from].end()) {
        _transitions[from][to](*_data);
      }
    }
  }


  // Setup initial state links
  void setup(state_t state) {
        FSM::stop_requested = false;
    
    _state.first = state;
    _state.second = state;
  }

  // Evaluate the current state and update the next state
  // to be used when main loop is customized (i.e., not using FSM::run())
  state_t eval_state() {
      _state.first = _state.second;
      _state.second = (*this)(_state.second);
      (*this)(_state.first, _state.second);
      return _state.second;
  }

  // Run the FSM from a given state
  void run(state_t state, operation_fun operation = nullptr) {
    setup(state);
    std::signal(SIGINT, [](int signum) {
      FSM::stop_requested = true; 
    });
    do {
      if (operation) {
        operation(*_data);
      }
      eval_state();
      if (_timing_func) {
        _timing_func();
      }
    } while (_state.second != STATE_STOP);
    // Call the exit state once more:
    (*this)(STATE_STOP);
    std::signal(SIGINT, SIG_DFL);
  }

  // Run the FSM from the initial state
  void run(operation_fun operation = nullptr) { run(STATE_INIT, operation); }

  // install state and transition functions
  void install_functions() {

    // State functions
    add_state(FSM::STATE_INIT, [](DATA_T &data) -> FSM::state_t {
      FSM::state_t next_state = do_init(data);
    
      switch (next_state) {
      case FSM::UNIMPLEMENTED:
        throw std::runtime_error("State function not fully implemented: "s + "INIT");
        break;
      case FSM::STATE_IDLE:
      case FSM::STATE_STOP:
        break;
      default:
        next_state = FSM::NO_CHANGE;
      }
      return next_state;
    });

    add_state(FSM::STATE_IDLE, [](DATA_T &data) -> FSM::state_t {
      FSM::state_t next_state = do_idle(data);
    
      switch (next_state) {
      case FSM::UNIMPLEMENTED:
        throw std::runtime_error("State function not fully implemented: "s + "IDLE");
        break;
      case FSM::NO_CHANGE:
      case FSM::STATE_IDLE:
      case FSM::STATE_LOAD_BLOCK:
      case FSM::STATE_STOP:
      case FSM::STATE_GO_TO_ZERO:
        break;
      default:
        next_state = FSM::NO_CHANGE;
      }
      // SIGINT transition override
      if (stop_requested) next_state = STATE_STOP;
      return next_state;
    });

    add_state(FSM::STATE_STOP, [](DATA_T &data) -> FSM::state_t {
      FSM::state_t next_state = do_stop(data);
    
      switch (next_state) {
      case FSM::UNIMPLEMENTED:
        throw std::runtime_error("State function not fully implemented: "s + "STOP");
        break;
      case FSM::NO_CHANGE:
        break;
      default:
        next_state = FSM::NO_CHANGE;
      }
      return next_state;
    });

    add_state(FSM::STATE_LOAD_BLOCK, [](DATA_T &data) -> FSM::state_t {
      FSM::state_t next_state = do_load_block(data);
    
      switch (next_state) {
      case FSM::UNIMPLEMENTED:
        throw std::runtime_error("State function not fully implemented: "s + "LOAD_BLOCK");
        break;
      case FSM::STATE_IDLE:
      case FSM::STATE_NO_MOTION:
      case FSM::STATE_RAPID_MOTION:
      case FSM::STATE_INTERP_MOTION:
        break;
      default:
        next_state = FSM::NO_CHANGE;
      }
      return next_state;
    });

    add_state(FSM::STATE_GO_TO_ZERO, [](DATA_T &data) -> FSM::state_t {
      FSM::state_t next_state = do_go_to_zero(data);
    
      switch (next_state) {
      case FSM::UNIMPLEMENTED:
        throw std::runtime_error("State function not fully implemented: "s + "GO_TO_ZERO");
        break;
      case FSM::NO_CHANGE:
      case FSM::STATE_IDLE:
      case FSM::STATE_GO_TO_ZERO:
        break;
      default:
        next_state = FSM::NO_CHANGE;
      }
      // SIGINT transition override
      if (stop_requested) next_state = STATE_STOP;
      return next_state;
    });

    add_state(FSM::STATE_NO_MOTION, [](DATA_T &data) -> FSM::state_t {
      FSM::state_t next_state = do_no_motion(data);
    
      switch (next_state) {
      case FSM::UNIMPLEMENTED:
        throw std::runtime_error("State function not fully implemented: "s + "NO_MOTION");
        break;
      case FSM::STATE_LOAD_BLOCK:
        break;
      default:
        next_state = FSM::NO_CHANGE;
      }
      return next_state;
    });

    add_state(FSM::STATE_RAPID_MOTION, [](DATA_T &data) -> FSM::state_t {
      FSM::state_t next_state = do_rapid_motion(data);
    
      switch (next_state) {
      case FSM::UNIMPLEMENTED:
        throw std::runtime_error("State function not fully implemented: "s + "RAPID_MOTION");
        break;
      case FSM::NO_CHANGE:
      case FSM::STATE_LOAD_BLOCK:
      case FSM::STATE_RAPID_MOTION:
        break;
      default:
        next_state = FSM::NO_CHANGE;
      }
      // SIGINT transition override
      if (stop_requested) next_state = STATE_STOP;
      return next_state;
    });

    add_state(FSM::STATE_INTERP_MOTION, [](DATA_T &data) -> FSM::state_t {
      FSM::state_t next_state = do_interp_motion(data);
    
      switch (next_state) {
      case FSM::UNIMPLEMENTED:
        throw std::runtime_error("State function not fully implemented: "s + "INTERP_MOTION");
        break;
      case FSM::NO_CHANGE:
      case FSM::STATE_LOAD_BLOCK:
      case FSM::STATE_INTERP_MOTION:
        break;
      default:
        next_state = FSM::NO_CHANGE;
      }
      // SIGINT transition override
      if (stop_requested) next_state = STATE_STOP;
      return next_state;
    });


    // Transition functions
    add_transition(STATE_IDLE, STATE_LOAD_BLOCK, [](DATA_T &data) {
      reset(data);
    });

    add_transition(STATE_IDLE, STATE_GO_TO_ZERO, [](DATA_T &data) {
      begin_zero(data);
    });

    add_transition(STATE_LOAD_BLOCK, STATE_RAPID_MOTION, [](DATA_T &data) {
      begin_rapid(data);
    });

    add_transition(STATE_LOAD_BLOCK, STATE_INTERP_MOTION, [](DATA_T &data) {
      begin_interp(data);
    });

    add_transition(STATE_RAPID_MOTION, STATE_LOAD_BLOCK, [](DATA_T &data) {
      end_rapid(data);
    });

    add_transition(STATE_INTERP_MOTION, STATE_LOAD_BLOCK, [](DATA_T &data) {
      end_interp(data);
    });

    add_transition(STATE_GO_TO_ZERO, STATE_IDLE, [](DATA_T &data) {
      end_zero(data);
    });

  }

}; // class FiniteStateMachine

}; // namespace FSM

#endif // FSM_HPP

